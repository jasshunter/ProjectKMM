// This file automatically generated by MOKO KSwift (https://github.com/icerockdev/moko-kswift)
//
import MultiPlatformLibrary

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/notifications/ListChange */
public enum ListChangeKs<T : AnyObject> {

  case deletedList(DeletedList)
  case initialList(InitialList)
  case updatedList(UpdatedList)

  public var sealed: ListChange {
    switch self {
    case .deletedList(let obj):
      return obj as! MultiPlatformLibrary.ListChange
    case .initialList(let obj):
      return obj as! MultiPlatformLibrary.ListChange
    case .updatedList(let obj):
      return obj as! MultiPlatformLibrary.ListChange
    }
  }

  public init(_ obj: ListChange) {
    if let obj = obj as? MultiPlatformLibrary.DeletedList {
      self = .deletedList(obj)
    } else if let obj = obj as? MultiPlatformLibrary.InitialList {
      self = .initialList(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UpdatedList {
      self = .updatedList(obj)
    } else {
      fatalError("ListChangeKs not synchronized with ListChange class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/notifications/MapChange */
public enum MapChangeKs<K : AnyObject, V : AnyObject> {

  case deletedMap(DeletedMap)
  case initialMap(InitialMap)
  case updatedMap(UpdatedMap)

  public var sealed: MapChange {
    switch self {
    case .deletedMap(let obj):
      return obj as! MultiPlatformLibrary.MapChange
    case .initialMap(let obj):
      return obj as! MultiPlatformLibrary.MapChange
    case .updatedMap(let obj):
      return obj as! MultiPlatformLibrary.MapChange
    }
  }

  public init(_ obj: MapChange) {
    if let obj = obj as? MultiPlatformLibrary.DeletedMap {
      self = .deletedMap(obj)
    } else if let obj = obj as? MultiPlatformLibrary.InitialMap {
      self = .initialMap(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UpdatedMap {
      self = .updatedMap(obj)
    } else {
      fatalError("MapChangeKs not synchronized with MapChange class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/notifications/ObjectChange */
public enum ObjectChangeKs<O : BaseRealmObject> {

  case deletedObject(DeletedObject)
  case initialObject(InitialObject)
  case updatedObject(UpdatedObject)

  public var sealed: ObjectChange {
    switch self {
    case .deletedObject(let obj):
      return obj as! MultiPlatformLibrary.ObjectChange
    case .initialObject(let obj):
      return obj as! MultiPlatformLibrary.ObjectChange
    case .updatedObject(let obj):
      return obj as! MultiPlatformLibrary.ObjectChange
    }
  }

  public init(_ obj: ObjectChange) {
    if let obj = obj as? MultiPlatformLibrary.DeletedObject {
      self = .deletedObject(obj)
    } else if let obj = obj as? MultiPlatformLibrary.InitialObject {
      self = .initialObject(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UpdatedObject {
      self = .updatedObject(obj)
    } else {
      fatalError("ObjectChangeKs not synchronized with ObjectChange class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/notifications/RealmChange */
public enum RealmChangeKs<R : BaseRealm> {

  case initialRealm(InitialRealm)
  case updatedRealm(UpdatedRealm)

  public var sealed: RealmChange {
    switch self {
    case .initialRealm(let obj):
      return obj as! MultiPlatformLibrary.RealmChange
    case .updatedRealm(let obj):
      return obj as! MultiPlatformLibrary.RealmChange
    }
  }

  public init(_ obj: RealmChange) {
    if let obj = obj as? MultiPlatformLibrary.InitialRealm {
      self = .initialRealm(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UpdatedRealm {
      self = .updatedRealm(obj)
    } else {
      fatalError("RealmChangeKs not synchronized with RealmChange class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/notifications/ResultsChange */
public enum ResultsChangeKs<T : BaseRealmObject> {

  case initialResults(InitialResults)
  case updatedResults(UpdatedResults)

  public var sealed: ResultsChange {
    switch self {
    case .initialResults(let obj):
      return obj as! MultiPlatformLibrary.ResultsChange
    case .updatedResults(let obj):
      return obj as! MultiPlatformLibrary.ResultsChange
    }
  }

  public init(_ obj: ResultsChange) {
    if let obj = obj as? MultiPlatformLibrary.InitialResults {
      self = .initialResults(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UpdatedResults {
      self = .updatedResults(obj)
    } else {
      fatalError("ResultsChangeKs not synchronized with ResultsChange class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/notifications/SetChange */
public enum SetChangeKs<T : AnyObject> {

  case deletedSet(DeletedSet)
  case initialSet(InitialSet)
  case updatedSet(UpdatedSet)

  public var sealed: SetChange {
    switch self {
    case .deletedSet(let obj):
      return obj as! MultiPlatformLibrary.SetChange
    case .initialSet(let obj):
      return obj as! MultiPlatformLibrary.SetChange
    case .updatedSet(let obj):
      return obj as! MultiPlatformLibrary.SetChange
    }
  }

  public init(_ obj: SetChange) {
    if let obj = obj as? MultiPlatformLibrary.DeletedSet {
      self = .deletedSet(obj)
    } else if let obj = obj as? MultiPlatformLibrary.InitialSet {
      self = .initialSet(obj)
    } else if let obj = obj as? MultiPlatformLibrary.UpdatedSet {
      self = .updatedSet(obj)
    } else {
      fatalError("SetChangeKs not synchronized with SetChange class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/notifications/SingleQueryChange */
public enum SingleQueryChangeKs<O : BaseRealmObject> {

  case objectChange(ObjectChange)
  case pendingObject(PendingObject)

  public var sealed: SingleQueryChange {
    switch self {
    case .objectChange(let obj):
      return obj as! MultiPlatformLibrary.SingleQueryChange
    case .pendingObject(let obj):
      return obj as! MultiPlatformLibrary.SingleQueryChange
    }
  }

  public init(_ obj: SingleQueryChange) {
    if let obj = obj as? MultiPlatformLibrary.ObjectChange {
      self = .objectChange(obj)
    } else if let obj = obj as? MultiPlatformLibrary.PendingObject {
      self = .pendingObject(obj)
    } else {
      fatalError("SingleQueryChangeKs not synchronized with SingleQueryChange class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/schema/RealmPropertyType */
public enum RealmPropertyTypeKs {

  case listPropertyType(ListPropertyType)
  case mapPropertyType(MapPropertyType)
  case setPropertyType(SetPropertyType)
  case valuePropertyType(ValuePropertyType)

  public var sealed: RealmPropertyType {
    switch self {
    case .listPropertyType(let obj):
      return obj as! MultiPlatformLibrary.RealmPropertyType
    case .mapPropertyType(let obj):
      return obj as! MultiPlatformLibrary.RealmPropertyType
    case .setPropertyType(let obj):
      return obj as! MultiPlatformLibrary.RealmPropertyType
    case .valuePropertyType(let obj):
      return obj as! MultiPlatformLibrary.RealmPropertyType
    }
  }

  public init(_ obj: RealmPropertyType) {
    if let obj = obj as? MultiPlatformLibrary.ListPropertyType {
      self = .listPropertyType(obj)
    } else if let obj = obj as? MultiPlatformLibrary.MapPropertyType {
      self = .mapPropertyType(obj)
    } else if let obj = obj as? MultiPlatformLibrary.SetPropertyType {
      self = .setPropertyType(obj)
    } else if let obj = obj as? MultiPlatformLibrary.ValuePropertyType {
      self = .valuePropertyType(obj)
    } else {
      fatalError("RealmPropertyTypeKs not synchronized with RealmPropertyType class")
    }
  }

}

/**
 * selector: ClassContext/io.realm.kotlin:library-base/io/realm/kotlin/migration/RealmMigration */
public enum RealmMigrationKs {

  case automaticSchemaMigration(AutomaticSchemaMigration)

  public var sealed: RealmMigration {
    switch self {
    case .automaticSchemaMigration(let obj):
      return obj as! MultiPlatformLibrary.RealmMigration
    }
  }

  public init(_ obj: RealmMigration) {
    if let obj = obj as? MultiPlatformLibrary.AutomaticSchemaMigration {
      self = .automaticSchemaMigration(obj)
    } else {
      fatalError("RealmMigrationKs not synchronized with RealmMigration class")
    }
  }

}
