// This file automatically generated by MOKO KSwift (https://github.com/icerockdev/moko-kswift)
//
import shared

/**
 * selector: ClassContext/io.ktor:ktor-http/io/ktor/http/ContentRange */
public enum ContentRangeKs {

  case bounded(ContentRange.Bounded)
  case suffix(ContentRange.Suffix)
  case tailFrom(ContentRange.TailFrom)

  public var sealed: ContentRange {
    switch self {
    case .bounded(let obj):
      return obj as! shared.ContentRange
    case .suffix(let obj):
      return obj as! shared.ContentRange
    case .tailFrom(let obj):
      return obj as! shared.ContentRange
    }
  }

  public init(_ obj: ContentRange) {
    if let obj = obj as? shared.ContentRange.Bounded {
      self = .bounded(obj)
    } else if let obj = obj as? shared.ContentRange.Suffix {
      self = .suffix(obj)
    } else if let obj = obj as? shared.ContentRange.TailFrom {
      self = .tailFrom(obj)
    } else {
      fatalError("ContentRangeKs not synchronized with ContentRange class")
    }
  }

}

/**
 * selector: ClassContext/io.ktor:ktor-http/io/ktor/http/auth/HttpAuthHeader */
public enum HttpAuthHeaderKs {

  case parameterized(HttpAuthHeader.Parameterized)
  case single(HttpAuthHeader.Single)

  public var sealed: HttpAuthHeader {
    switch self {
    case .parameterized(let obj):
      return obj as! shared.HttpAuthHeader
    case .single(let obj):
      return obj as! shared.HttpAuthHeader
    }
  }

  public init(_ obj: HttpAuthHeader) {
    if let obj = obj as? shared.HttpAuthHeader.Parameterized {
      self = .parameterized(obj)
    } else if let obj = obj as? shared.HttpAuthHeader.Single {
      self = .single(obj)
    } else {
      fatalError("HttpAuthHeaderKs not synchronized with HttpAuthHeader class")
    }
  }

}

/**
 * selector: ClassContext/io.ktor:ktor-http/io/ktor/http/content/OutgoingContent */
public enum OutgoingContentKs {

  case byteArrayContent(OutgoingContent.ByteArrayContent)
  case noContent(OutgoingContent.NoContent)
  case protocolUpgrade(OutgoingContent.ProtocolUpgrade)
  case readChannelContent(OutgoingContent.ReadChannelContent)
  case writeChannelContent(OutgoingContent.WriteChannelContent)

  public var sealed: OutgoingContent {
    switch self {
    case .byteArrayContent(let obj):
      return obj as! shared.OutgoingContent
    case .noContent(let obj):
      return obj as! shared.OutgoingContent
    case .protocolUpgrade(let obj):
      return obj as! shared.OutgoingContent
    case .readChannelContent(let obj):
      return obj as! shared.OutgoingContent
    case .writeChannelContent(let obj):
      return obj as! shared.OutgoingContent
    }
  }

  public init(_ obj: OutgoingContent) {
    if let obj = obj as? shared.OutgoingContent.ByteArrayContent {
      self = .byteArrayContent(obj)
    } else if let obj = obj as? shared.OutgoingContent.NoContent {
      self = .noContent(obj)
    } else if let obj = obj as? shared.OutgoingContent.ProtocolUpgrade {
      self = .protocolUpgrade(obj)
    } else if let obj = obj as? shared.OutgoingContent.ReadChannelContent {
      self = .readChannelContent(obj)
    } else if let obj = obj as? shared.OutgoingContent.WriteChannelContent {
      self = .writeChannelContent(obj)
    } else {
      fatalError("OutgoingContentKs not synchronized with OutgoingContent class")
    }
  }

}

/**
 * selector: ClassContext/io.ktor:ktor-http/io/ktor/http/content/PartData */
public enum PartDataKs {

  case binaryChannelItem(PartData.BinaryChannelItem)
  case binaryItem(PartData.BinaryItem)
  case fileItem(PartData.FileItem)
  case formItem(PartData.FormItem)

  public var sealed: PartData {
    switch self {
    case .binaryChannelItem(let obj):
      return obj as! shared.PartData
    case .binaryItem(let obj):
      return obj as! shared.PartData
    case .fileItem(let obj):
      return obj as! shared.PartData
    case .formItem(let obj):
      return obj as! shared.PartData
    }
  }

  public init(_ obj: PartData) {
    if let obj = obj as? shared.PartData.BinaryChannelItem {
      self = .binaryChannelItem(obj)
    } else if let obj = obj as? shared.PartData.BinaryItem {
      self = .binaryItem(obj)
    } else if let obj = obj as? shared.PartData.FileItem {
      self = .fileItem(obj)
    } else if let obj = obj as? shared.PartData.FormItem {
      self = .formItem(obj)
    } else {
      fatalError("PartDataKs not synchronized with PartData class")
    }
  }

}
